const VIDEO_PX_WIDTH           = 320;
const VIDEO_PX_HEIGHT          = 240;
const VIDEO_BITS_PER_PX        =   1;
const VIDEO_WORDS_PER_SCANLINE = ((VIDEO_PX_WIDTH * VIDEO_BITS_PER_PX) / 16);
const VIDEO_SIZE_WORDS         = (VIDEO_WORDS_PER_SCANLINE * VIDEO_PX_HEIGHT);
auto  VIDEO[VIDEO_SIZE_WORDS];

const FONT_ATLAS_SIZE_WORDS = 380;
auto FONT_ATLAS[FONT_ATLAS_SIZE_WORDS] = {
	0xfffd, 0xfdfd, 0xfffd, 0xffff, 0xfff5, 0xf5ff,
	0xffff, 0xffff, 0xffeb, 0xc1eb, 0xc1eb, 0xffff,
	0xffc3, 0xe9c1, 0xcbe1, 0xffff, 0xffdd, 0xeff7,
	0xfbdd, 0xffff, 0xfff1, 0xfbd5, 0xedd3, 0xffff,
	0xfffd, 0xfdff, 0xffff, 0xffff, 0xfffb, 0xfdfd,
	0xfdfb, 0xffff, 0xfffd, 0xfbfb, 0xfbfd, 0xffff,
	0xffff, 0xf5fb, 0xf5ff, 0xffff, 0xffff, 0xfbf1,
	0xfbff, 0xffff, 0xffff, 0xffff, 0xfbfd, 0xffff,
	0xffff, 0xfff1, 0xffff, 0xffff, 0xffff, 0xffff,
	0xfffd, 0xffff, 0xffdf, 0xeff7, 0xfbfd, 0xffff,
	0xffe3, 0xddd5, 0xdde3, 0xffff, 0xfff7, 0xf3f7,
	0xf7e3, 0xffff, 0xffe1, 0xdfe3, 0xfdc1, 0xffff,
	0xffe1, 0xdfe3, 0xdfe1, 0xffff, 0xffdd, 0xddc1,
	0xdfdf, 0xffff, 0xffc1, 0xfde1, 0xdfe1, 0xffff,
	0xffe3, 0xfde1, 0xdde3, 0xffff, 0xffc1, 0xdfcf,
	0xdfdf, 0xffff, 0xffe3, 0xdde3, 0xdde3, 0xffff,
	0xffc3, 0xddc3, 0xdfdf, 0xffff, 0xffff, 0xfdff,
	0xfdff, 0xffff, 0xffff, 0xfbff, 0xfbfd, 0xffff,
	0xfff7, 0xfbfd, 0xfbf7, 0xffff, 0xffff, 0xf1ff,
	0xf1ff, 0xffff, 0xfffd, 0xfbf7, 0xfbfd, 0xffff,
	0xffe1, 0xdfe1, 0xfffd, 0xffff, 0xffe3, 0xcdd5,
	0xcdfb, 0xffff, 0xfff7, 0xebdd, 0xc1dd, 0xffff,
	0xfff1, 0xede1, 0xdde1, 0xffff, 0xffc3, 0xfdfd,
	0xfdc3, 0xffff, 0xffe1, 0xdddd, 0xdde1, 0xffff,
	0xffc1, 0xfde1, 0xfdc1, 0xffff, 0xffc1, 0xfde1,
	0xfdfd, 0xffff, 0xffc3, 0xfdcd, 0xddc3, 0xffff,
	0xffdd, 0xddc1, 0xdddd, 0xffff, 0xffe3, 0xf7f7,
	0xf7e3, 0xffff, 0xffc1, 0xdfdf, 0xdde3, 0xffff,
	0xffdd, 0xdde1, 0xdddd, 0xffff, 0xfffd, 0xfdfd,
	0xfdc1, 0xffff, 0xffc9, 0xd5dd, 0xdddd, 0xffff,
	0xffdd, 0xd9d5, 0xcddd, 0xffff, 0xffe3, 0xdddd,
	0xdde3, 0xffff, 0xffe1, 0xdde1, 0xfdfd, 0xffff,
	0xffe3, 0xdddd, 0xcdc3, 0xffff, 0xffe1, 0xddc1,
	0xeddd, 0xffff, 0xffc3, 0xfde3, 0xdfe1, 0xffff,
	0xffc1, 0xf7f7, 0xf7f7, 0xffff, 0xffdd, 0xdddd,
	0xdde3, 0xffff, 0xffdd, 0xdddd, 0xebf7, 0xffff,
	0xffdd, 0xdddd, 0xd5c9, 0xffff, 0xffdd, 0xdde3,
	0xdddd, 0xffff, 0xffdd, 0xddeb, 0xf7f7, 0xffff,
	0xffc1, 0xdfe3, 0xfdc1, 0xffff, 0xfff9, 0xfdfd,
	0xfdf9, 0xffff, 0xfffd, 0xfbf7, 0xefdf, 0xffff,
	0xfff9, 0xfbfb, 0xfbf9, 0xffff, 0xfffb, 0xf5ff,
	0xffff, 0xffff, 0xffff, 0xffff, 0xffc1, 0xffff,
	0xfffd, 0xfbff, 0xffff, 0xffff, 0xffff, 0xc3dd,
	0xddc3, 0xffff, 0xfffd, 0xfde1, 0xdde1, 0xffff,
	0xffff, 0xc3fd, 0xfdc3, 0xffff, 0xffdf, 0xdfc3,
	0xddc3, 0xffff, 0xffff, 0xe3c1, 0xfdc3, 0xffff,
	0xffe7, 0xfbf3, 0xfbfb, 0xffff, 0xffff, 0xc3dd,
	0xc3df, 0xe3ff, 0xfffd, 0xfde1, 0xdddd, 0xffff,
	0xfff7, 0xfff3, 0xf7e3, 0xffff, 0xffdf, 0xffdf,
	0xdfdd, 0xe3ff, 0xfffd, 0xdde1, 0xdddd, 0xffff,
	0xfffb, 0xfbfb, 0xfbe7, 0xffff, 0xffff, 0xe1d5,
	0xdddd, 0xffff, 0xffff, 0xe1dd, 0xdddd, 0xffff,
	0xffff, 0xe3dd, 0xdde3, 0xffff, 0xffff, 0xe1dd,
	0xe1fd, 0xfdff, 0xffff, 0xc3dd, 0xc3df, 0xdfff,
	0xffff, 0xc5f9, 0xfdfd, 0xffff, 0xffff, 0xc3f9,
	0xc7e1, 0xffff, 0xfffb, 0xf3fb, 0xfbe7, 0xffff,
	0xffff, 0xdddd, 0xdde3, 0xffff, 0xffff, 0xdddd,
	0xebf7, 0xffff, 0xffff, 0xdddd, 0xd5eb, 0xffff,
	0xffff, 0xdde3, 0xdddd, 0xffff, 0xffff, 0xdddd,
	0xc3df, 0xe3ff, 0xffff, 0xc1ef, 0xf3c1, 0xffff,
	0xfff3, 0xfbfd, 0xfbf3, 0xffff, 0xfffd, 0xfdfd,
	0xfdfd, 0xffff, 0xfff9, 0xfbf7, 0xfbf9, 0xffff,
	0xffeb, 0xf5ff, 0xffff, 0xffff, 0xffc1, 0xc1c1,
	0xc1c1, 0xffff
};

const FONT_BITS_PER_PX             =   1;
const FONT_ATLAS_PX_WIDTH          =   8;
const FONT_ATLAS_PX_HEIGHT         = 760;
const FONT_ATLAS_CHAR_WIDTH_COUNT  =   1;
const FONT_ATLAS_CHAR_HEIGHT_COUNT =  95;
const FONT_CHAR_PX_WIDTH           =   6;
const FONT_CHAR_PX_HEIGHT          =   8;
const FONT_CHAR_SCANLINES_PER_WORD =   2;
const FONT_SIZE_WORDS              = ((FONT_ATLAS_PX_WIDTH * FONT_ATLAS_PX_HEIGHT * FONT_BITS_PER_PX) / 16);

const FONT_CHAR_ASCII_START =  33;
const FONT_CHAR_ASCII_END   = 126;

const VIDEO_CHARS_WIDTH  = VIDEO_PX_WIDTH  / FONT_CHAR_PX_WIDTH;
const VIDEO_CHARS_HEIGHT = VIDEO_PX_HEIGHT / FONT_CHAR_PX_HEIGHT;

draw_glyph(ch, x, y)
{
	if (ch == 32) { return x + 1; }
	if (ch ==  9) { return x / 4 * 4; }
	if (ch == 10) { return x; }
	if (ch == 13) { return 0; }

	auto glyph = FONT_ATLAS;
	if (ch < FONT_CHAR_ASCII_START || ch > FONT_CHAR_ASCII_END) {
		glyph = ((FONT_CHAR_ASCII_END + 1) * FONT_CHAR_PX_HEIGHT) / FONT_CHAR_SCANLINES_PER_WORD;
	} else {
		glyph = (ch * FONT_CHAR_PX_HEIGHT) / FONT_CHAR_SCANLINES_PER_WORD;
	}

	auto video = VIDEO + VIDEO_WORDS_PER_SCANLINE * y * FONT_CHAR_PX_HEIGHT + (x / FONT_CHAR_SCANLINES_PER_WORD);
	y = 0;
	if (x % FONT_CHAR_SCANLINES_PER_WORD == 0) {
		while (y < FONT_CHAR_PX_HEIGHT) {
			auto mask = 0xff00;
			*video = *video | (mask & glyph);
			video = video + VIDEO_WORDS_PER_SCANLINE;
			mask = mask >> 8;
			*video = *video | ((mask & glyph) << 8);
			video = video + VIDEO_WORDS_PER_SCANLINE;
			glyph = glyph + 1;
			y = y + 2;
		}
	} else {
		while (y < FONT_CHAR_PX_HEIGHT) {
			auto mask = 0xff00;
			*video = *video | ((mask & glyph) >> 8);
			video = video + VIDEO_WORDS_PER_SCANLINE;
			mask = mask >> 8;
			*video = *video | (mask & glyph);
			video = video + VIDEO_WORDS_PER_SCANLINE;
			glyph = glyph + 1;
			y = y + 2;
		}
	}
	
	return x + 1;
}

draw_text(text, len, x, y)
{
	auto i = 0;
	while (i < len) {
		x = draw_glyph(text[i], x, y);
		i = i + 1;
	}
	return x;
}

const NUM_PORTS = 16;

auto __devices[NUM_PORTS];

get_connection_id(port_idex, out_packet)
{
}

scan_ports(dev_arr)
{

}

/// @brief Checks a given port if its bus has pending messages.
/// @param port_index The port index to check for pending messages.
/// @return 1 if the given port has pending messages on its bus. 0 otherwise.
hwpend(port_index)
{
	auto msg_pending;
	asm {
		put port_index.
		port.
		pend.
		mov msg_pending;
	}
	return msg_pending;
}

/// @brief Attempts to poll a message from a specific port index. Does not consume the message.
/// @param port_index The port to sniff for a message.
/// @param header Pointer to the packet header.
/// @param data Pointer to the packet payload.
/// @return 1 if there was a message to consume. 0 otherwise.
hwpeek(port_index, header, data)
{
	auto pending = hwpend(port_index);
	if (pending) {
		asm {
			port port_index.
			poll header, data.
		}
	}
	return pending;
}

/// @brief Does a scan of the given port to retrieve the hardware ID of the connected device.
/// @param port_index The port to scan.
/// @return The hardware ID of the device connected at the port. 0 if there is no device connected.
/// @note There is no way of knowing for sure if there is a device connected on a port other than to see if there are pending messages on the bus or if a potential device responds to a ping. If a ping is sent, this function may block for up to a second while polling the bus for a response message. After the time is up the function abandons its retries. However, a device could still potentially be connected, just too busy to respond on time or its message buffer being full and dropping messages.
hwid(port_index)
{
	const MAX_PAYLOAD_SIZE = 26;

	// The packet data.
	auto id;
	auto clck;
	auto type; 
	auto seq;
	auto size;
	auto irq;
	auto data[MAX_PAYLOAD_SIZE];

	// First check if there is already an event on the bus we can peek.
	if (hwpeek(port_index, &id, data) == 0) {
		// Constants.
		const TYPE_PING = 3; // The constant representing a ping request.
		
		// Initialize a PING request.
		id   = cpuid();
		clck = clock();
		type = TYPE_PING; 
		seq  = 0;
		size = 0;
		irq  = 0;

		// Select the port to output the data to.
		asm {
			port port_index. // Select port.
			pass &id, 0.     // Put the address of the header but we send no data, so just point to null.Send the values at the addresses to the selected port.
		}

		// We give a device 1 second to respond, checking every iteration.
		auto poll_until = clock() + 1;
		while (hwpeek(port_index, &id, data) == 0) {
			if (clock() > poll_until) {
				id = 0;
				break;
			}
		}
	}
	return id;
}

hwid(port_index)
{

}

hwscan(id)
{
	auto i = 0;
	while (i < NUM_PORTS) {
		if (hwid(i) == id) {
			return i;
		}
		++i;
	}
	return -1;
}

const HWID_KB      = 0x0001;
const HWID_MONITOR = 0x0003;
const HWID_READER  = 0x0002; 

main(a,b)
{
	scan_ports(__devices);


	
	auto x = 0;
	x = draw_glyph( 72, x, 0);
	x = draw_glyph(101, x, 0);
	x = draw_glyph(108, x, 0);
	x = draw_glyph(108, x, 0);
	x = draw_glyph(111, x, 0);
	x = draw_glyph( 44, x, 0);
	x = draw_glyph( 32, x, 0);
	x = draw_glyph( 87, x, 0);
	x = draw_glyph(111, x, 0);
	x = draw_glyph(114, x, 0);
	x = draw_glyph(108, x, 0);
	x = draw_glyph(100, x, 0);
	x = draw_glyph( 33, x, 0);
	return 0;
}
