//#include <sys>

const BIOS_MAJ_VER = 0;
const BIOS_MIN_VER = 1;
const BIOS_HOT_VER = 0;

const VIDEO_PX_WIDTH           = 320;
const VIDEO_PX_HEIGHT          = 240;
const VIDEO_BITS_PER_PX        =   1;
const VIDEO_WORDS_PER_SCANLINE = ((VIDEO_PX_WIDTH * VIDEO_BITS_PER_PX) / 16);
const VIDEO_SIZE_WORDS         = (VIDEO_WORDS_PER_SCANLINE * VIDEO_PX_HEIGHT);
auto  VIDEO[VIDEO_SIZE_WORDS];

const FONT_ATLAS_SIZE_WORDS = 380;
auto FONT_ATLAS[FONT_ATLAS_SIZE_WORDS] = {
	0xfffd, 0xfdfd, 0xfffd, 0xffff, 0xfff5, 0xf5ff,
	0xffff, 0xffff, 0xffeb, 0xc1eb, 0xc1eb, 0xffff,
	0xffc3, 0xe9c1, 0xcbe1, 0xffff, 0xffdd, 0xeff7,
	0xfbdd, 0xffff, 0xfff1, 0xfbd5, 0xedd3, 0xffff,
	0xfffd, 0xfdff, 0xffff, 0xffff, 0xfffb, 0xfdfd,
	0xfdfb, 0xffff, 0xfffd, 0xfbfb, 0xfbfd, 0xffff,
	0xffff, 0xf5fb, 0xf5ff, 0xffff, 0xffff, 0xfbf1,
	0xfbff, 0xffff, 0xffff, 0xffff, 0xfbfd, 0xffff,
	0xffff, 0xfff1, 0xffff, 0xffff, 0xffff, 0xffff,
	0xfffd, 0xffff, 0xffdf, 0xeff7, 0xfbfd, 0xffff,
	0xffe3, 0xddd5, 0xdde3, 0xffff, 0xfff7, 0xf3f7,
	0xf7e3, 0xffff, 0xffe1, 0xdfe3, 0xfdc1, 0xffff,
	0xffe1, 0xdfe3, 0xdfe1, 0xffff, 0xffdd, 0xddc1,
	0xdfdf, 0xffff, 0xffc1, 0xfde1, 0xdfe1, 0xffff,
	0xffe3, 0xfde1, 0xdde3, 0xffff, 0xffc1, 0xdfcf,
	0xdfdf, 0xffff, 0xffe3, 0xdde3, 0xdde3, 0xffff,
	0xffc3, 0xddc3, 0xdfdf, 0xffff, 0xffff, 0xfdff,
	0xfdff, 0xffff, 0xffff, 0xfbff, 0xfbfd, 0xffff,
	0xfff7, 0xfbfd, 0xfbf7, 0xffff, 0xffff, 0xf1ff,
	0xf1ff, 0xffff, 0xfffd, 0xfbf7, 0xfbfd, 0xffff,
	0xffe1, 0xdfe1, 0xfffd, 0xffff, 0xffe3, 0xcdd5,
	0xcdfb, 0xffff, 0xfff7, 0xebdd, 0xc1dd, 0xffff,
	0xfff1, 0xede1, 0xdde1, 0xffff, 0xffc3, 0xfdfd,
	0xfdc3, 0xffff, 0xffe1, 0xdddd, 0xdde1, 0xffff,
	0xffc1, 0xfde1, 0xfdc1, 0xffff, 0xffc1, 0xfde1,
	0xfdfd, 0xffff, 0xffc3, 0xfdcd, 0xddc3, 0xffff,
	0xffdd, 0xddc1, 0xdddd, 0xffff, 0xffe3, 0xf7f7,
	0xf7e3, 0xffff, 0xffc1, 0xdfdf, 0xdde3, 0xffff,
	0xffdd, 0xdde1, 0xdddd, 0xffff, 0xfffd, 0xfdfd,
	0xfdc1, 0xffff, 0xffc9, 0xd5dd, 0xdddd, 0xffff,
	0xffdd, 0xd9d5, 0xcddd, 0xffff, 0xffe3, 0xdddd,
	0xdde3, 0xffff, 0xffe1, 0xdde1, 0xfdfd, 0xffff,
	0xffe3, 0xdddd, 0xcdc3, 0xffff, 0xffe1, 0xddc1,
	0xeddd, 0xffff, 0xffc3, 0xfde3, 0xdfe1, 0xffff,
	0xffc1, 0xf7f7, 0xf7f7, 0xffff, 0xffdd, 0xdddd,
	0xdde3, 0xffff, 0xffdd, 0xdddd, 0xebf7, 0xffff,
	0xffdd, 0xdddd, 0xd5c9, 0xffff, 0xffdd, 0xdde3,
	0xdddd, 0xffff, 0xffdd, 0xddeb, 0xf7f7, 0xffff,
	0xffc1, 0xdfe3, 0xfdc1, 0xffff, 0xfff9, 0xfdfd,
	0xfdf9, 0xffff, 0xfffd, 0xfbf7, 0xefdf, 0xffff,
	0xfff9, 0xfbfb, 0xfbf9, 0xffff, 0xfffb, 0xf5ff,
	0xffff, 0xffff, 0xffff, 0xffff, 0xffc1, 0xffff,
	0xfffd, 0xfbff, 0xffff, 0xffff, 0xffff, 0xc3dd,
	0xddc3, 0xffff, 0xfffd, 0xfde1, 0xdde1, 0xffff,
	0xffff, 0xc3fd, 0xfdc3, 0xffff, 0xffdf, 0xdfc3,
	0xddc3, 0xffff, 0xffff, 0xe3c1, 0xfdc3, 0xffff,
	0xffe7, 0xfbf3, 0xfbfb, 0xffff, 0xffff, 0xc3dd,
	0xc3df, 0xe3ff, 0xfffd, 0xfde1, 0xdddd, 0xffff,
	0xfff7, 0xfff3, 0xf7e3, 0xffff, 0xffdf, 0xffdf,
	0xdfdd, 0xe3ff, 0xfffd, 0xdde1, 0xdddd, 0xffff,
	0xfffb, 0xfbfb, 0xfbe7, 0xffff, 0xffff, 0xe1d5,
	0xdddd, 0xffff, 0xffff, 0xe1dd, 0xdddd, 0xffff,
	0xffff, 0xe3dd, 0xdde3, 0xffff, 0xffff, 0xe1dd,
	0xe1fd, 0xfdff, 0xffff, 0xc3dd, 0xc3df, 0xdfff,
	0xffff, 0xc5f9, 0xfdfd, 0xffff, 0xffff, 0xc3f9,
	0xc7e1, 0xffff, 0xfffb, 0xf3fb, 0xfbe7, 0xffff,
	0xffff, 0xdddd, 0xdde3, 0xffff, 0xffff, 0xdddd,
	0xebf7, 0xffff, 0xffff, 0xdddd, 0xd5eb, 0xffff,
	0xffff, 0xdde3, 0xdddd, 0xffff, 0xffff, 0xdddd,
	0xc3df, 0xe3ff, 0xffff, 0xc1ef, 0xf3c1, 0xffff,
	0xfff3, 0xfbfd, 0xfbf3, 0xffff, 0xfffd, 0xfdfd,
	0xfdfd, 0xffff, 0xfff9, 0xfbf7, 0xfbf9, 0xffff,
	0xffeb, 0xf5ff, 0xffff, 0xffff, 0xffc1, 0xc1c1,
	0xc1c1, 0xffff
};

const FONT_BITS_PER_PX             =   1;
const FONT_ATLAS_PX_WIDTH          =   8;
const FONT_ATLAS_PX_HEIGHT         = 760;
const FONT_ATLAS_CHAR_WIDTH_COUNT  =   1;
const FONT_ATLAS_CHAR_HEIGHT_COUNT =  95;
const FONT_CHAR_PX_WIDTH           =   6;
const FONT_CHAR_PX_HEIGHT          =   8;
const FONT_CHAR_SCANLINES_PER_WORD =   2;
const FONT_SIZE_WORDS              = ((FONT_ATLAS_PX_WIDTH * FONT_ATLAS_PX_HEIGHT * FONT_BITS_PER_PX) / 16);

const FONT_CHAR_ASCII_START =  33;
const FONT_CHAR_ASCII_END   = 126;

const TEXTMODE_CHARS_WIDTH  = VIDEO_PX_WIDTH  / FONT_CHAR_PX_WIDTH;
const TEXTMODE_CHARS_HEIGHT = VIDEO_PX_HEIGHT / FONT_CHAR_PX_HEIGHT;

auto TXTMODE_SCROLL_OFFSET = 0; // This can allow the text to scroll by a single line without having to redraw the entire map.

const HWID_KB   = 0x0001; // Hardware ID of keyboard.
const HWID_RDD  = 0x0002; // Hardware ID of disk reader.
const HWID_MON  = 0x0003; // Hardware ID of monitor.
const HWID_DISK = 0x0004; // Hardware ID of disk reader.
const HWID_BELL = 0x0005; // Hardware ID of on-board bell.
const HWID_TERM = 0x0006; // Hardware ID of integrated terminal.

// Monitor message types.
const MON_MSG_PIXMODE              = 0xface; // Sets the monitor mode to direct pixel manipulation.
const MON_MSG_TXTMODE              = 0xbeef; // Sets the monitor mode to text mode which only requires the computer to send font atlas information to the monitor, and then a text map, allowing the monitor to do the rendering.
const MON_MSG_TXTMODE_LOADSCANLINE = 0xdef0; // Transfers a single line of text from the text map to the monitor.
const MON_MSG_TXTMODE_LOADFONT     = 0xabcd; // Writes the local bitfont to the monitor internal memory for use in text mode.
const MON_MSG_TXTMODE_LOADFONTMETA = 0xaffe; // Writes metadata about the bitfont to the monitor (such as width and height of the atlas, width and height of individual characters, etc.)

const NUM_PORTS = 16;     // The number of ports on this machine.
auto __hwids[NUM_PORTS]; // The hardware ID:s of each port.

d_hwscan()
{
	auto i = 0;
	while (i < NUM_PORTS) {
//		__hwids[i] = hwid(i);
		++i;
	}
}

const PORT_UNDEF = 0xffff; // The port index of an unfound device.

d_find_hw(id)
{
	auto i = 0;
	while (i < NUM_PORTS && __hwids[i] != HWID_MON) {
		++i;
	}
	if (i == NUM_PORTS) {
		return PORT_UNDEF;
	}
	return i;
}

d_require_hw(id)
{
	auto port = d_find_hw(id);
	if (port == PORT_UNDEF) {
		// [ ] Print message if possible
		while (1) {
			// [ ] call bell with type=7
		}
	}
	return port;
}

auto __port_bell = PORT_UNDEF; // The port index where the system bell is connected.

d_init_bell()
{
	__port_bell = d_find_hw(HWID_BELL);
	if (__port_bell == PORT_UNDEF) {
		return 0;
	}
	return 1;
}

auto __port_mon = PORT_UNDEF; // The port index where the monitor is connected.

d_init_monitor(mode)
{
	__port_mon = d_require_hw(HWID_MON);
	// [ ] set up monitor with specified mode
	return 1;
}

i_print_sys_info()
{
	auto xerxes_str[39] = "XERXES(tm) Unified Nanocontroller (XUN)";
	auto bios_str[6] = "BIOS v";
	auto sep_str[1] = ".";
	// [ ] print general info

	auto cycles = 8;
//	asm { // BUG: Something is wrong with this assembly (stack corruption?). Re-write in C?
//		$scope: start {           // 2 (PUT PUSH)
//			clock.                // 1 (CLOCK)
//			mov start.            // 3 (PUT RLB MOVU)
//			%calc_cycles:         // 1 (PUT)
//				put 19.           // 1 (PUT)
//				put cycles.       // 3 (PUT RLB AT)
//				add.              // 1 (ADD)
//				mov cycles.       // 2 (PUT RLB)
//				clock.            // 1 (CLOCK)
//				put start.        // 3 (PUT RLB AT)
//				sub.              // 1 (SUB)
//				put 10.           // 1 (PUT)
//				lt.               // 1 (LT)
//				put %calc_cycles. // 3 (PUT RLA AT)
//				cjmp.             // 1 (CJMP)
//		}                         // 2 (PUT POP)
//
//	}
	// hz = cycles * 10000;
	// [ ] print Hz (don't have instructions for this so maybe we can just run a few instructions, time them and calculate it ourselves... lol)
	
	auto ram_remaining;
	asm {
		put 0xffff, $top.
		sub.
		mov ram_remaining.
	}
	// [ ] print available RAM
}

i_print_connected_devices()
{
	auto i = 0;
	while (i < NUM_PORTS) {
		// [ ] print(i);
		// [ ] print(": ");
		// [ ] print(__hwids[i]);
		++i;
	}
}

auto __port_kb = PORT_UNDEF; // The port index here the keyboard is connected.

d_init_keyboard()
{
	__port_kb = d_require_hw(HWID_KB);
}

auto __port_disk = PORT_UNDEF; // The port index where the disk reader is connected.

d_init_diskreader()
{
	__port_disk = d_require_hw(HWID_DISK);
}

s_load_bootdisk()
{
	// [ ] Load program on the disk
	// [ ] If no disk present print error message, spinloop
}

sleep(ms)
{
	auto now;
	asm {
		clock.
		mov now.
	}
	auto to = now + ms;
	if (to < now) {
		while (now > 0) {
			asm {
				clock.
				mov now.
			}
		}
	}
	while (now < to) {
		asm {
			clock.
			mov now.
		}
	}
}

main(a,b)
{
	d_hwscan();
	d_init_bell();
	d_init_monitor(MON_MSG_TXTMODE);
//	i_print_sys_info();
//	d_init_diskreader();
//	i_print_connected_devices();
//	// d_init_keyboard(); // Not really necessary because BIOS takes no user input
//	s_load_bootdisk();

	//auto msg[13] = "Hello, World!";
	//print(msg, 13);

	sleep(2000);

	return 0;
}
