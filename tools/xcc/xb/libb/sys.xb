#include <time>
#include <stdlib>

cpuid()
{
	auto id;
	asm {
		cpuid.
		mov id.
	}
	return id;
}

const __NUM_HWPORTS = 16; // The number of ports available on this hardware.

hwpush(port_index, data_ptr, len)
{
	// Constants.
	const TYPE_DATA        = 5; // The constant representing data transmission.
	const MAX_PAYLOAD_SIZE = 26;

	// The packet data.
	auto id    = cpuid();
	auto clck  = clock();
	auto type  = TYPE_DATA; 
	auto seq   = 0;
	auto size;
	auto irq   = 0; // We do not use this field.

	// Select the port to output the data to.
	asm {
		put port_index.
		port.
	}

	// Split the data up into several numbered packages.
	while (len > 0) {
		if (len > MAX_PAYLOAD_SIZE) {
			size = MAX_PAYLOAD_SIZE;
			len -= MAX_PAYLOAD_SIZE;
		} else {
			size = len;
			len = 0;
		}
		asm {
			put &id, data_ptr.
			pass. // Put the address of the header and the data, and send the values at the addresses to the selected port. 
		}
		data_ptr += MAX_PAYLOAD_SIZE;
		++seq;
	}
}

hwpend(port_index)
{
	auto msg_pending;
	asm {
		put port_index.
		port.
		pend.
		mov msg_pending;
	}
	return msg_pending;
}

hwid(port_index)
{
	const MAX_PAYLOAD_SIZE = 26;

	// The packet data.
	auto id;
	auto clck;
	auto type; 
	auto seq;
	auto size;
	auto irq;
	auto data[MAX_PAYLOAD_SIZE];

	// First check if there is already an event on the bus we can peek.
	if (hwpeek(port_index, &id, data) == 0) {
		// Constants.
		const TYPE_PING = 3; // The constant representing a ping request.
		
		// Initialize a PING request.
		id   = cpuid();
		clck = clock();
		type = TYPE_PING; 
		seq  = 0;
		size = 0;
		irq  = 0;

		// Select the port to output the data to.
		asm {
			put port_index. // Select port.
			port.
			put &id, 0.
			pass.     // Put the address of the header but we send no data, so just point to null.Send the values at the addresses to the selected port.
		}

		// We give a device 1 second to respond, checking every iteration.
		auto poll_until = clock() + 1;
		while (hwpeek(port_index, &id, data) == 0) {
			if (clock() > poll_until) {
				id = 0;
				break;
			}
		}
	}
	return id;
}

hwscan(id)
{
	auto i = 0;
	while (i < __NUM_HWPORTS) {
		if (hwid(i) == id) {
			return i;
		}
		++i;
	}
	return -1;
}

hwpeek(port_index, header_ptr, data_ptr)
{
	auto pending = hwpend(port_index);
	if (pending) {
		asm {
			put port_index.
			port.
			put header_ptr, data_ptr.
			poll.
		}
	}
	return pending;
}

auto __irq_table[256]; // A table with function pointers to be called upon an interrupt request. Takes two arguments; a pointer to packet header data, and a pointer to packet payload data.

hwpoll(port_index, header_ptr, data_ptr)
{
	auto pending = hwpeek(port_index, header_ptr, data_ptr);
	if (pending) {
		asm ack.
		if (irq < 256 && __irq_table[irq]) {
			__irq_table[irq](header_ptr, data_ptr);
		}
	}
	return pending;
}

sleep(ms)
{
	// BUG If 'to' wraps (which it very often will) then the program will not sleep at all.
	auto to = clock() + ms;
	while (clock() < to) {}
}

run(bin)
{
	// TODO IMPL
	return -1;
}

auto __hw_power = hwscan(0x0004); // The port index of the power controller circuit.

shutdown()
{
	// TODO IMPL
}
