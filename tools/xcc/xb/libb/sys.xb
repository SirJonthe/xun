#include <time.xb>
#include <stdlib.xb>

/// @brief Returns the CPU ID.
/// @return The CPU ID.
cpuid()
{
	auto id;
	asm {
		cpuid.
		mov &id.
	}
	return id;
}

const __NUM_HWPORTS = 16; // The number of ports available on this hardware.

/// @brief Sends data to a device at a given port.
/// @param port_index The port to send the data to.
/// @param data Pointer to data to send to the port.
/// @param len The number of data points to send to the port in words. If this is greater than the maximum payload size then several indexed packages will be sent.
/// @note If the amount of data is greater than the bus bandwidth, then the program will stall until the device consumes enough data to resume execution.
hwpush(port_index, data, len)
{
	// Constants.
	const TYPE_DATA        = 5; // The constant representing data transmission.
	const MAX_PAYLOAD_SIZE = 26;

	// The packet data.
	auto id    = cpuid();
	auto clck  = clock();
	auto type  = TYPE_DATA; 
	auto seq   = 0;
	auto size;
	auto irq   = 0; // We do not use this field.

	// Select the port to output the data to.
	asm { port port_index. }

	// Split the data up into several numbered packages.
	while (len > 0) {
		if (len > MAX_PAYLOAD_SIZE) {
			size = MAX_PAYLOAD_SIZE;
			len -= MAX_PAYLOAD_SIZE;
		} else {
			size = len;
			len = 0;
		}
		asm {
			pass &id, data. // Put the address of the header and the data, and send the values at the addresses to the selected port. 
		}
		data += MAX_PAYLOAD_SIZE;
		++seq;
	}
}

/// @brief Checks a given port if its bus has pending messages.
/// @param port_index The port index to check for pending messages.
/// @return 1 if the given port has pending messages on its bus. 0 otherwise.
hwpend(port_index)
{
	auto msg_pending;
	asm {
		port port_index.
		pend.
		mov &msg_pending;
	}
	return msg_pending;
}

/// @brief Does a scan of the given port to retrieve the hardware ID of the connected device.
/// @param port_index The port to scan.
/// @return The hardware ID of the device connected at the port. 0 if there is no device connected.
/// @note There is no way of knowing for sure if there is a device connected on a port other than to see if there are pending messages on the bus or if a potential device responds to a ping. If a ping is sent, this function may block for up to a second while polling the bus for a response message. After the time is up the function abandons its retries. However, a device could still potentially be connected, just too busy to respond on time or its message buffer being full and dropping messages.
hwid(port_index)
{
	const MAX_PAYLOAD_SIZE = 26;

	// The packet data.
	auto id;
	auto clck;
	auto type; 
	auto seq;
	auto size;
	auto irq;
	auto data[MAX_PAYLOAD_SIZE];

	// First check if there is already an event on the bus we can peek.
	if (hwpeek(port_index, &id, data) == 0) {
		// Constants.
		const TYPE_PING = 3; // The constant representing a ping request.
		
		// Initialize a PING request.
		id   = cpuid();
		clck = clock();
		type = TYPE_PING; 
		seq  = 0;
		size = 0;
		irq  = 0;

		// Select the port to output the data to.
		asm {
			port port_index. // Select port.
			pass &id, 0.     // Put the address of the header but we send no data, so just point to null.Send the values at the addresses to the selected port.
		}

		// We give a device 1 second to respond, checking every iteration.
		auto poll_until = clock() + 1;
		while (hwpeek(port_index, &id, data) == 0) {
			if (clock() > poll_until) {
				id = 0;
				break;
			}
		}
	}
	return id;
}

/// @brief Scans all available ports to look for a connected device with the requested hardware ID.
/// @param id The hardware ID of the requested device.
/// @return The port in which a device of the given hardware ID is plugged in. Returns -1 if the device was not found.
hwscan(id)
{
	auto i = 0;
	while (i < __NUM_HWPORTS) {
		if (hwid(i) == id) {
			return i;
		}
		++i;
	}
	return -1;
}

/// @brief Attempts to poll a message from a specific port index. Does not consume the message.
/// @param port_index The port to sniff for a message.
/// @param header Pointer to the packet header.
/// @param data Pointer to the packet payload.
/// @return 1 if there was a message to consume. 0 otherwise.
hwpeek(port_index, header, data)
{
	auto pending = hwpend(port_index);
	if (pending) {
		asm {
			port port_index.
			poll header, data.
		}
	}
	return pending;
}

auto __irq_table[256]; // A table with function pointers to be called upon an interrupt request. Takes two arguments; a pointer to packet header data, and a pointer to packet payload data.

/// @brief Attempts to poll a message from a specific port index. Consumes the message. If there is an IRQ function associated with the header IRQ request, that function is executed.
/// @param port_index The port to sniff for a message.
/// @param header Pointer to the packet header.
/// @param data Pointer to the packet payload.
/// @return 1 if there was a message to consume. 0 otherwise.
hwpoll(port_index, header, data)
{
	auto pending = hwpeek(port_index, header, data);
	if (pending) {
		asm { ack. }
		if (irq < 256 && __irq_table[irq]) {
			__irq_table[irq](header, data);
		}
	}
	return pending;
}

/// @brief Puts execution of the application to sleep for a specified number of milliseconds.
/// @param ms The time to sleep in milliseconds.
/// @note Sleeps at least the specified number of milliseconds, but may sleep more.
sleep(ms)
{
	// BUG If 'to' wraps (which it very often will) then the program will not sleep at all.
	auto to = clock() + ms;
	while (clock() < to) {}
}

/// @brief Runs a binary file as a program. Returns execution here only once the program is done running.
/// @param bin The name of the file containing the binary to run.
run(bin)
{
	// TODO IMPL
	return -1;
}

auto __hw_power = hwscan(0x0004); // The port index of the power controller circuit.

/// @brief Turns the computer off.
/// @note The processor has no control to turn the computer off, so it relies on a circuit breaker being connected to the machine which it can communicate with.
/// @warning Use this sparingly.
shutdown()
{
	// TODO IMPL
}